#!/usr/bin/env bash
set -euo pipefail

# ========= Config =========
CONDA_DIR="$HOME/miniconda3"
CONDA_ENV="lerobot"
MINICONDA_URL="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-aarch64.sh"
UDEV_RULE="/etc/udev/rules.d/99-usb-serial-aliases.rules"
# ==========================

usage() {
  cat <<'EOF'
Gebruik: ./setup_lerobot_conda_udev.sh <mapping.csv>

Mapping-bestand: CSV/TSV/space met per regel:
  SERIAL_SHORT, NICE_NAME, ROLE

ROLE: leader of follower (case-insensitive)
Voorbeeld:
  5A46084108,black,leader
  5AAF287935,black,follower
  94A990446518,esp_jtag,leader

Symlinks die worden gemaakt:
  /dev/tty_<role>               (bv. /dev/tty_leader)
  /dev/tty_<role>_<nice>        (bv. /dev/tty_leader_black)
EOF
}

[[ "${1:-}" == "-h" || "${1:-}" == "--help" || $# -ne 1 ]] && { usage; exit 1; }
MAPFILE_PATH="$1"
[[ -f "$MAPFILE_PATH" ]] || { echo "‚ùå Niet gevonden: $MAPFILE_PATH"; exit 1; }

ARCH="$(uname -m)"
[[ "$ARCH" == "aarch64" ]] || { echo "‚ùå Verwacht aarch64 (64-bit). Gevonden: $ARCH"; exit 1; }

# ---- 1) Miniconda installeren (idempotent) ----
if [[ -x "$CONDA_DIR/bin/conda" ]]; then
  echo "‚úÖ Miniconda al aanwezig: $CONDA_DIR"
else
  echo "‚¨áÔ∏è  Download Miniconda‚Ä¶"
  TMP_SH="$(mktemp /tmp/miniconda.XXXXXX.sh)"
  curl -fsSL "$MINICONDA_URL" -o "$TMP_SH"
  echo "üõ†  Installeren naar $CONDA_DIR‚Ä¶"
  bash "$TMP_SH" -b -p "$CONDA_DIR"
  rm -f "$TMP_SH"
fi

# Conda in deze shell
# shellcheck disable=SC1091
source "$CONDA_DIR/etc/profile.d/conda.sh"

# ---- 2) Env 'lerobot' met Python 3.10 + lerobot ----
if conda env list | awk '{print $1}' | grep -qx "$CONDA_ENV"; then
  echo "‚úÖ Conda env bestaat: $CONDA_ENV"
else
  echo "üß™ Maak env $CONDA_ENV (python=3.10)‚Ä¶"
  conda create -y -n "$CONDA_ENV" python=3.10
fi

echo "üì¶ pip install lerobot‚Ä¶"
conda activate "$CONDA_ENV"
pip install --upgrade pip
pip install lerobot[feetech]

# ---- 3) Udev rules genereren ----
echo "üîß Genereer udev-regels uit $MAPFILE_PATH‚Ä¶"

# Eerst alle entries parsen en in temp bewaren om role-counts te kunnen bepalen
TMP_ENTRIES="$(mktemp /tmp/entries.XXXXXX)"
> "$TMP_ENTRIES"

parse_line() {
  local line="$1"
  # trim
  line="${line#"${line%%[![:space:]]*}"}"; line="${line%"${line##*[![:space:]]}"}"
  [[ -z "$line" || "${line:0:1}" == "#" ]] && return 1
  # normaliseer scheiding: tabs en meerdere spaties -> komma
  local norm; norm="$(echo "$line" | tr '\t' ',' | tr -s ' ' ',' )"
  local serial nice role
  serial="$(echo "$norm" | cut -d',' -f1)"
  nice="$(echo   "$norm" | cut -d',' -f2)"
  role="$(echo   "$norm" | cut -d',' -f3)"
  [[ -z "$serial" || -z "$nice" || -z "$role" ]] && return 1

  # schoonmaken
  serial="$(echo "$serial" | tr -cd '[:alnum:]')"
  nice="$(echo "$nice" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_]/_/g')"
  role="$(echo "$role" | tr '[:upper:]' '[:lower:]')"
  [[ "$role" == "leader" || "$role" == "follower" ]] || return 1

  echo "$serial,$nice,$role"
  return 0
}

while IFS= read -r raw; do
  if parsed="$(parse_line "$raw")"; then
    echo "$parsed" >> "$TMP_ENTRIES"
  else
    [[ -n "$raw" && "${raw:0:1}" != "#" ]] && echo "‚ö†Ô∏è  Overslaan: $raw" >&2
  fi
done < "$MAPFILE_PATH"

# Tel roles
count_role() {
  local r="$1"
  grep -c ",$r$" "$TMP_ENTRIES" || true
}
N_LEADER="$(count_role leader)"
N_FOLLOWER="$(count_role follower)"

# Backup bestaand rules-bestand
if [[ -f "$UDEV_RULE" ]]; then
  sudo cp -a "$UDEV_RULE" "${UDEV_RULE}.bak.$(date +%Y%m%d-%H%M%S)"
  echo "üóÇ  Backup: ${UDEV_RULE}.bak.*"
fi

TMP_RULE="$(mktemp /tmp/udev.rules.XXXXXX)"
{
  echo "# Auto-generated by $0 on $(date)"
  echo "# Kolommen: SERIAL_SHORT,NICE_NAME,ROLE"
  echo "# Symlinks: /dev/tty_<nice>, /dev/tty_<role>_<nice>"
  if [[ "$N_LEADER" == "1" ]]; then
    echo "# Extra: /dev/tty_leader (exact 1 leader gedetecteerd)"
  fi
  if [[ "$N_FOLLOWER" == "1" ]]; then
    echo "# Extra: /dev/tty_follower (exact 1 follower gedetecteerd)"
  fi
} > "$TMP_RULE"

# Per entry regels
while IFS= read -r ent; do
  IFS=',' read -r serial nice role <<<"$ent"
  # Altijd: tty_<nice> en tty_<role>_<nice>
  echo "SUBSYSTEM==\"tty\", ENV{ID_BUS}==\"usb\", ENV{ID_SERIAL_SHORT}==\"$serial\", SYMLINK+=\"tty_${nice}\", SYMLINK+=\"tty_${role}_${nice}\"" >> "$TMP_RULE"
done < "$TMP_ENTRIES"

# Optioneel unieke generieke role-symlinks
# (alleen veilig als rol maar 1 keer voorkomt)
gen_generic_rule() {
  local role="$1"
  local symlink="tty_${role}"
  local serial nice
  IFS=',' read -r serial nice _ < <(grep ",${role}$" "$TMP_ENTRIES")
  echo "SUBSYSTEM==\"tty\", ENV{ID_BUS}==\"usb\", ENV{ID_SERIAL_SHORT}==\"$serial\", SYMLINK+=\"${symlink}\""
}
[[ "$N_LEADER" == "1" ]]   && gen_generic_rule leader   >> "$TMP_RULE"
[[ "$N_FOLLOWER" == "1" ]] && gen_generic_rule follower >> "$TMP_RULE"

# Schrijf rules
echo "üìù Schrijf naar $UDEV_RULE‚Ä¶"
sudo mv "$TMP_RULE" "$UDEV_RULE"
sudo chown root:root "$UDEV_RULE"
sudo chmod 0644 "$UDEV_RULE"

echo "üîÅ Udev reload + trigger‚Ä¶"
sudo udevadm control --reload
sudo udevadm trigger

# ---- 4) Dialout-tip ----
if ! id -nG "$USER" | grep -qw dialout; then
  echo "üë• Voeg jezelf toe aan 'dialout' voor /dev/tty* toegang:"
  echo "    sudo usermod -aG dialout $USER"
fi

echo
echo "‚úÖ Klaar!"
echo "   - conda activate $CONDA_ENV"
echo "   - Rules: $UDEV_RULE"
echo "   - (Herplug USB-adapters of reboot voor nieuwe symlinks)"
